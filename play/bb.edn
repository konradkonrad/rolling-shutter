{:min-bb-version "0.7.3"
 :paths ["src"]
 :tasks
 {:requires ([babashka.fs :as fs :refer [which]]
             [babashka.core]
             [clojure.string :as str]
             [clojure.java.browse :as browse]
             [clojure.java.io :as io]
             [babashka.curl :as curl]
             [cheshire.core :as json]
             [sht.play :as play])

  :init
  (do

    (defn long-from-env
      [s default]
      (Long/valueOf (or (System/getenv s) default)))

    (def num-keypers (long-from-env "PLAY_NUM_KEYPERS" "3"))
    (def num-decryptors (long-from-env "PLAY_NUM_DECRYPTORS" "3"))

    (def windows? (babashka.core/windows?))
    (def no-color? windows?)

    (defn decryptor-db [n]
      (format "decryptor-db-%d" n))

    (defn keyper-port [n]
      (-> n play/keyper-subcommand :subcommand/p2p-port))

    (defn inside-asdf?
      [path]
      (let [asdf-dir (some-> "ASDF_DIR" System/getenv fs/canonicalize (str "/"))
            path (some-> path fs/canonicalize str)]
        (if (or (nil? asdf-dir) (nil? path))
          false
          (str/starts-with? path asdf-dir))))
    (def asdf-go?
      (inside-asdf? (fs/which "go")))

    (def repo-root
      (str (fs/canonicalize (or (System/getenv "ROLLING_SHUTTER_ROOT") ".."))))
    (def src-dir
      (-> repo-root (fs/path "rolling-shutter") str))
    (defn src-file [p]
      (-> src-dir (fs/path p) str))
    (def contracts-dir
      (-> src-dir (fs/path ".." "contracts") fs/canonicalize str))

    (def insert-keyper-set-sql "insert_keyper_set.sql")
    (def insert-decryptor-sql "insert_decryptor.sql")
    (def insert-eon-key-sql "insert_eon_public_key.sql")

    (def exe (src-file (str "bin/rolling-shutter" (if windows? ".exe"))))
    (def ansi-green (if no-color? "" "\u001B[32m"))
    (def ansi-reset (if no-color? "" "\u001B[0m"))
    (defn log
      [& args]
      (print ansi-green (format "==> [%s] " (:name (current-task))))
      (apply print args)
      (println ansi-reset))
    (play/set-bb-log! log)
    (defn download-to
      [url path]
      (log "Downloading" url "to" path)
      (io/copy
       (:body (curl/get url {:as :stream}))
       (io/file path)))

    (defn extract-address [cfgfile]
      (re-find (re-pattern "0x[0-9a-fA-F]{40}") (slurp cfgfile)))

    (defn extract-peerid [cfgfile]
      (second (re-find (re-pattern "(?m)(?i)^# Peer identity: /p2p/([0-9a-zA-Z]*)") (slurp cfgfile))))

    (defn extract-bls-key [cfgfile]
      (second (re-find (re-pattern "(?m)(?i)^# BLS public key: ([0-9a-zA-Z]*)") (slurp cfgfile))))

    (defn extract-eon-key [cfgfile]
      (second (re-find (re-pattern "(?m)(?i)^# Eon Public Key: ([0-9a-zA-Z]*)") (slurp cfgfile))))

    (defn extract-toml-value [cfgfile key]
      (second (re-find (re-pattern (format "(?m)^\\s*%s\\s*=\\s*(.*)" key)) (slurp cfgfile))))

    (defn extract-toml-value-str [cfgfile key]
      (let [v-with-quotes (extract-toml-value cfgfile key)]
        (subs v-with-quotes 1 (dec (count v-with-quotes)))))

    (defn toml-replace
      [toml-str key value]
      (str/replace-first
       toml-str
       (re-pattern (format "(?m)(^\\s*%s\\s*=)(.*)" key))
       (str "$1 " (json/encode value))))

    (defn toml-edit-string
      [toml-str m]
      (reduce (fn [toml-str [k v]]
                (toml-replace toml-str k v))
              toml-str
              m))

    (defn toml-edit-file
      [filename m]
      (spit filename (toml-edit-string (slurp filename) m)))

    (defn decryptor-cfg
      [n]
      (format "decryptor-%s.toml" n))

    (def mock-cfg "mock.toml")
    (def collator-cfg "collator.toml")


    (defn myshell
      [& args]
      (log args)
      (let [[opts args] (if (map? (first args))
                          [(first args) (rest args)]
                          [{} args])
            dir (:dir opts)]
        (when dir
          (println (format "Entering directory '%s'" dir)))
        (apply shell opts args)
        (when dir
          (println (format "Leaving directory '%s'" dir)))))

    (defn gotest
      [& args]
      (let [args (concat ["gotestsum" (if no-color? " --no-color ") "--"]
                         args
                         (or *command-line-args* ["./..."]))
            args (remove nil? args)]
        (apply myshell {:dir src-dir} args)))

    (defn go-install
      ([pkg]
       (myshell {:dir src-dir} "go" "install" pkg)
       (when asdf-go?
         (myshell "asdf" "reshim" "golang")))
      ([executable pkg]
       (when (nil? (which executable))
         (go-install pkg)
         (when (nil? (which executable))
           (throw (ex-info "Cannot find the executable installed with go install. Check your PATH"
                           {:executable executable :pkg pkg}))))))
    (defn rs
      [& args]
      (apply myshell exe args))

    (defn psql
      [db & args]
      (apply (partial myshell "psql -d" db) args)))


  -godoc:idx
  {:depends [-install:godoc]
   :task (let [path (src-file "godoc.idx")]
           (when-not (fs/exists? path)
             (myshell {:dir src-dir} "godoc -index -index_files=godoc.idx -write_index -v"))
           path)}
  ;; the computation of the relative path here seems excessive and it probably is, as it returns
  ;; "../contracts/deployments" unless we're not using the default directory structure.
  -deployments
  (when-not (fs/exists? "deployments" {:nofollow-links true})
    (let [target (-> repo-root (fs/path "contracts" "deployments") str)
          target (fs/relativize (fs/canonicalize ".") target)]
      (log (format "Symlinking deployments -> %s" target))
      (fs/create-sym-link "deployments" target)))

  -oapi-files
  (src-file "collator/oapi/oapi.yaml")

  -sqlc-files
  (concat [(src-file "sqlc.yaml")] (fs/glob src-dir "**.sql"))

  -go-files
  (concat (fs/glob src-dir "**.go") [(src-file "go.mod") (src-file "go.sum")])

  -protoc-files
  (fs/glob src-dir "**.proto")

  -install:protoc-gen-go
  (go-install "protoc-gen-go" "google.golang.org/protobuf/cmd/protoc-gen-go")

  -install:sqlc
  (go-install "sqlc" "github.com/kyleconroy/sqlc/cmd/sqlc")

  -install:gotestsum
  (go-install "gotestsum" "gotest.tools/gotestsum@latest")

  -install:abigen
  (go-install "abigen" "github.com/ethereum/go-ethereum/cmd/abigen")

  -install:oapi-codegen
  (go-install "oapi-codegen" "github.com/deepmap/oapi-codegen/cmd/oapi-codegen")

  -install:godoc
  (go-install "godoc" "golang.org/x/tools/cmd/godoc@latest")

  contracts:install
  {:doc "Run npm install in contracts directory"
   :task (let [node-modules (format "%s/node_modules" contracts-dir)
               marker-file (format "%s/.mark-npm-install" node-modules)
               marker-exists? (fs/exists? marker-file)
               anchor (if marker-exists? marker-file node-modules)]
           ;; we use the marker file instead of node_modules as anchor to speedup the build, since
           ;; node_modules is rather large
           (when (seq (fs/modified-since anchor
                                         [(format "%s/package.json" contracts-dir)
                                          (format "%s/package-lock.json" contracts-dir)]))
             (myshell {:dir contracts-dir} "npm install")
             (if marker-exists?
               (fs/set-last-modified-time marker-file (System/currentTimeMillis))))
           (when-not marker-exists?
             (fs/create-file marker-file)))}

  contracts:test
  {:doc "Run hardhat tests in contracts directory"
   :depends [contracts:install]
   :task (myshell {:dir contracts-dir} "npx hardhat test")}

  build:abigen
  {:doc "Generate go bindings for the contracts"
   :depends [contracts:install -install:abigen]
   :task (when (seq (fs/modified-since (format "%s/combined.json" contracts-dir)
                                       (format "%s/src" contracts-dir)))
           (myshell {:dir contracts-dir} "node" "scripts/abigen.js"))}

  test
  {:doc "Run tests"
   :depends [-install:gotestsum]
   :task (gotest "-short")}

  test-integration
  {:doc "Run integration tests"
   :depends [-install:gotestsum]
   :task (gotest "-p=1" "-run=Integration" "-count=1")}

  test-all
  {:doc "Run all tests"
   :depends [test test-integration contracts:test]}

  test-system
  {:doc "Run whole system tests"
   :depends [build]
   :task (myshell {:dir (-> repo-root (fs/path "play") str)}
                  "clojure -X:run-tests")}

  lint
  {:doc "Run linter"
   :depends []
   :task (myshell {:dir src-dir} "golangci-lint run --tests")}

  lint-changes
  {:doc "Show only new linter warnings"
   :depends []
   :task (myshell {:dir src-dir} "golangci-lint run --new-from-rev origin/main")}

  build:oapi-codegen
  {:doc "Run oapi-codegen"
   :depends [-oapi-files]
   :task (when (seq (fs/modified-since exe -oapi-files))
           (run '-install:oapi-codegen)
           (myshell {:dir src-dir} "go generate -x ./collator/..."))}

  build:sqlc
  {:doc "Run sqlc"
   :depends [-sqlc-files]
   :task (when (and (not windows?)
                    (seq (fs/modified-since exe -sqlc-files)))
           (run '-install:sqlc)
           (myshell {:dir src-dir} "sqlc generate"))}

  build:protoc
  {:doc "Run protoc"
   :depends [-protoc-files]
   :task (when (seq (fs/modified-since exe -protoc-files))
           (run '-install:protoc-gen-go)
           (myshell {:dir src-dir} "go generate ./shmsg"))}

  build
  {:doc "Build rolling-shutter executable"
   :depends [build:abigen build:sqlc build:protoc build:oapi-codegen -go-files]
   :task (when (seq (fs/modified-since exe -go-files))
           (myshell {:dir src-dir} (if windows?
                                     "go build -o bin/rolling-shutter.exe"
                                     "make")))}

  build-all
  {:doc "Run all build/compile steps"
   :depends [build contracts:install]}

  ;; --------------------------------------
  ;; -- collator

  -collator-subcommand (play/collator-subcommand)

  genconfig:collator
  {:doc "Generate collator config"
   :depends [build -collator-subcommand]
   :task (play/generate-config -collator-subcommand)}

  init:collatordb
  {:doc "Initialize the collator database"
   :depends [build genconfig:collator]
   :task (play/initdb genconfig:collator)}

  -collator
  {:depends [genconfig:collator]
   :doc "Collator addresses"
   :task (-> genconfig:collator :subcommand/cfg :eth-address)}

  collator
  {:doc "Run collator"
   :depends [build genconfig:collator -deployments]
   :task (apply myshell (play/subcommand-run genconfig:collator))}

  ;; --------------------------------------
  ;; -- keyper
  -keyper-subcommands (mapv play/keyper-subcommand (range num-keypers))

  genconfig:keypers
  {:doc "Generate keyper configs"
   :depends [build -keyper-subcommands]
   :task (mapv play/generate-config -keyper-subcommands)}

  init:kprdb
  {:doc "Initialize the keyper database"
   :depends [build genconfig:keypers]
   :task (mapv play/initdb genconfig:keypers)}

  -keypers
  {:depends [genconfig:keypers]
   :doc "List of keyper addresses"
   :task (mapv (comp :eth-address :subcommand/cfg) genconfig:keypers)}

  ;; --------------------------------------
  ;; -- decryptor
  -decryptor-subcommands (mapv (partial play/decryptor-subcommand num-decryptors)
                               (range num-decryptors))

  genconfig:decryptors
  {:doc "Generate decryptor configs"
   :depends [build -decryptor-subcommands]
   :task (mapv play/generate-config -decryptor-subcommands)}

  init:decryptors
  {:doc "Initialize decryptor databases"
   :depends [build genconfig:decryptors]
   :task (mapv play/initdb genconfig:decryptors)}

  -decryptors
  {:depends [genconfig:decryptors]
   :doc "List of decryptor addresses"
   :task (mapv (comp :eth-address :subcommand/cfg) genconfig:decryptors)}

  ;; --------------------------------------
  ;; -- mocknode

  -mocknode-subcommand
  {:depends [genconfig:decryptors]
   :task (play/mocknode-subcommand genconfig:decryptors)}

  genconfig:mock
  {:doc "Generate mocknode config"
   :depends [build -mocknode-subcommand]
   :task (play/generate-config -mocknode-subcommand)}

  ;; -- general tasks
  genconfig
  {:doc "Generate configs"
   :depends [genconfig:keypers genconfig:decryptors genconfig:mock]}

  peer
  {:doc "Add nodes as peers of each other"
   :task (let [cfgs *command-line-args*
               peers (map (fn [cfg]
                            (str  (extract-toml-value-str cfg "ListenAddress")
                                  "/p2p/"
                                  (extract-peerid cfg)))
                          cfgs)]
           (doseq [cfg cfgs]
             (toml-edit-file cfg {"PeerMultiaddrs" peers})))}

  init:testchain
  {:doc "Initialize the shuttermint testchain directory"
   :depends [build]
   :task (do
           (fs/delete-tree "testchain")
           (rs "chain" "init" "--root" "testchain" "--dev" "--blocktime" "1"))}

  init
  {:doc "Initialize keyper and decryptor databases as well as shuttermint"
   :depends [genconfig init:testchain init:kprdb init:decryptors init:collatordb]}

  -deploy-conf
  {:doc "Generate a deploy config"
   :depends [-decryptors -keypers -collator]
   :task (let [conf {:keypers -keypers
                     :decryptors -decryptors
                     :collator -collator
                     :fundValue "100"}
               play-json (str (fs/absolutize "play.json"))]
           (spit play-json (json/encode conf {:pretty true}))
           play-json)}

  godoc
  {:doc "Run godoc"
   :depends [-godoc:idx]
   :task (do
           (print "===============> Starting godoc. Please wait a few seconds for the browser to open!\n" )
           (future
             (Thread/sleep 4000)
             (browse/browse-url "http://localhost:6060/"))
           (myshell {:dir src-dir} "godoc -index -index_files=godoc.idx -http=:6060"))}
  node
  {:doc "Start a hardhat node"
   :depends [-deploy-conf contracts:install]
   :task (myshell {:extra-env {"DEPLOY_CONF" -deploy-conf}
                   :dir contracts-dir}
                  "npx hardhat node")}

  populate:ds-with-ks
  {:doc "Populate decryptor dbs with keyper set"
   :depends [genconfig:decryptors -keypers]
   :task (let [kaddrs-quoted (map (partial format "\"%s\"") -keypers)
               kaddrs-args (format "'{%s}'" (str/join "," kaddrs-quoted))]
           (doseq [i (range num-decryptors)]
             (psql (decryptor-db i)
                   "-f" insert-keyper-set-sql
                   (format "-vkeypers=%s" kaddrs-args))))}

  populate:ds-with-ds
  {:doc "Populate decryptor dbs with decryptor set"
   :depends [genconfig:decryptors]
   :task (doseq [{:subcommand/keys [db]} genconfig:decryptors
                 i (range num-decryptors)
                 :let [cfg (decryptor-cfg i)
                       addr (extract-address cfg)
                       key (extract-bls-key cfg)]]
           (psql db
                 "-f" insert-decryptor-sql
                 (format "-vaddress='%s'" addr)
                 (format "-vkey=E'\\\\x%s'" key)))}

  populate:ds-with-eon-key
  {:doc "Populate decryptor dbs with eon key from mocknode"
   :depends [genconfig:decryptors genconfig:mock]
   :task (let [key (-> genconfig:mock :subcommand/cfg :eon-key)]
           (doseq [{:subcommand/keys [db]} genconfig:decryptors]
             (psql db
                   "-f" insert-eon-key-sql
                   (format "-veon_public_key=E'\\\\x%s'" key))))}

  populate:decryptors
  {:doc "Populate the decryptor databases"
   :depends [populate:ds-with-ks populate:ds-with-ds populate:ds-with-eon-key]}

  chain
  {:doc "Run shuttermint"
   :depends [build]
   :task (rs "chain" "--config" "testchain/config/config.toml")}

  boot
  {:doc "Bootstrap shuttermint node"
   :depends [build -deployments]
   :task (rs "bootstrap")}

  k
  {:doc "Run keyper"
   :depends [build genconfig:keypers -deployments]
   :task (let [n (Integer/parseInt (or (first *command-line-args*) "0"))
               subcommand (nth genconfig:keypers n)
               cmd (play/subcommand-run subcommand)]
           (apply myshell cmd))}

  d
  {:doc "Run decryptor"
   :depends [build genconfig:decryptors -deployments]
   :task (let [n (Integer/parseInt (or (first *command-line-args*) "0"))
               subcommand (nth genconfig:decryptors n)
               cmd (play/subcommand-run subcommand)]
           (apply myshell cmd))}

  m
  {:doc "Run mocknode"
   :depends [build genconfig:mock]
   :task (apply myshell (play/subcommand-run genconfig:mock))}


  clean
  {:doc "Remove config files and chain related files"
   :depends [-keyper-subcommands -decryptor-subcommands -collator-subcommand]
   :task (do
           (fs/delete-tree "testchain")
           (doseq [{:subcommand/keys [cfgfile]} (concat -keyper-subcommands
                                                        -decryptor-subcommands
                                                        [(play/mocknode-subcommand [])
                                                         -collator-subcommand])]
             (fs/delete-if-exists cfgfile)))}
  ci-gen sht.play/ci-gen}}
